#define _GNU_SOURCE

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <sys/syscall.h> 
#include <unistd.h>
#include <stdbool.h>

#include "util.h"
#include "kernel_constants.h"

#include "pipe_fds_t.h"
#include <linux/fcntl.h>

int raw_syscall_pipe(int *fildes)
{
    return syscall(__NR_pipe, fildes);
}

int raw_syscall_fcntl(int fildes, int op, int arg)
{
    return syscall(__NR_fcntl, fildes, op, arg);
}

void init_pipe_fds(pipe_fds_t *pipe_fds)
{
    int fds[2] = {0};
    check_error(
        raw_syscall_pipe(fds),
        "[-] Error while creating pipe.\n"    
    );

    pipe_fds->num_pages = PIPE_NUM_PAGES_START;
    pipe_fds->num_pages_in_use = 0;
    // pipe_fds->zero_buffer = calloc(PIPE_MAX_PAGES*PAGE_SIZE/sizeof(char), sizeof(char));
    pipe_fds->has_cached_page = false;
    
    pipe_fds->read_fd = fds[0];
    pipe_fds->write_fd = fds[1];
}

void destroy_pipe_fds(pipe_fds_t *pipe_fds)
{
    // free(pipe_fds->zero_buffer);
    close(pipe_fds->read_fd);
    close(pipe_fds->write_fd);
}

void pipe_read_page(pipe_fds_t *pipe_fds, char *buffer)
{
    pipe_fds->has_cached_page = true;
    if (pipe_fds->num_pages_in_use == 0)
        panic("[-] Can't read from empty pipe");
    pipe_fds->num_pages_in_use--;

    if (PAGE_SIZE != read(pipe_fds->read_fd, buffer, PAGE_SIZE))
        panic("[-] Error while reading from pipe");
}

void pipe_write_page(pipe_fds_t *pipe_fds, char *buffer)
{
    pipe_fds->has_cached_page = false;
    if (pipe_fds->num_pages_in_use == pipe_fds->num_pages)
        panic("[-] Can't write to full pipe");
    pipe_fds->num_pages_in_use++;

    if (PAGE_SIZE != read(pipe_fds->read_fd, buffer, PAGE_SIZE))
        panic("[-] Error while reading from pipe");
}

void pipe_read_pages(pipe_fds_t *pipe_fds, size_t num_pages)
{
    if (num_pages == 0)
        return;

    pipe_fds->has_cached_page = true;
 
    if (pipe_fds->num_pages_in_use < num_pages)
        panic("[-] Can't read this many pages from the pipe");
    pipe_fds->num_pages_in_use -= num_pages;
    
    size_t size_to_read = num_pages*PAGE_SIZE/sizeof(char);
    if (size_to_read
        != read(pipe_fds->read_fd, zero_buffer, size_to_read)) {
        panic("[-] Error while reading from pipe");
    };
}

void pipe_write_pages(pipe_fds_t *pipe_fds, size_t num_pages)
{
    if (num_pages == 0)
        return;

    pipe_fds->has_cached_page = false;
 
    pipe_fds->num_pages_in_use += num_pages;
    if (pipe_fds->num_pages_in_use > pipe_fds->num_pages)
        panic("[-] Can't write this many pages to the pipe");

    size_t size_to_write = num_pages*PAGE_SIZE/sizeof(char);
    if (size_to_write 
        != write(pipe_fds->write_fd, zero_buffer, size_to_write)) {
        panic("[-] Error while writing to pipe");
    };
}

void alloc_pipe_pages(pipe_fds_t *pipe_fds, size_t num_pages)
{
    if (num_pages == 0)
        return;

    if (pipe_fds->has_cached_page)
        num_pages += 1;
    
    pipe_write_pages(pipe_fds, num_pages);
}

void free_pipe_pages(pipe_fds_t *pipe_fds, size_t num_pages)
{
    if (num_pages == 0)
        return;

    if (!pipe_fds->has_cached_page)
        num_pages += 1;
    
    pipe_read_pages(pipe_fds, num_pages);
}

void resize_pipe(pipe_fds_t *pipe_fds, size_t num_pages)
{
    check_error(
        raw_syscall_fcntl(pipe_fds->read_fd, F_SETPIPE_SZ, num_pages*PAGE_SIZE),
        "[-] Error while resizing pipe.\n"    
    );

    pipe_fds->num_pages = num_pages;
}

uint64_t pipe_read_qword(pipe_fds_t *pipe_fds) {
    char buf[sizeof(uint64_t)];
    read(pipe_fds->read_fd, buf, sizeof(uint64_t));
    return *((uint64_t*)buf);
}

void pipe_write_qword(pipe_fds_t *pipe_fds, uint64_t value) {
    char buf[sizeof(value)];
    *(uint64_t*)buf = value; 
    write(pipe_fds->write_fd, buf, sizeof(value));
}